# *** Сортировка слиянием ***
# Сначала делим массив пополам (или почти пополам, если в массиве нечетное количество элементов).
# И снова пополам. И снова. Еще раз. Пока не устанете.
# Ладно, на самом деле программа сама это сделает, если использовать рекурсию.
# А выход из рекурсии случится тогда, когда отделенный кусок массива станет размером 1, т. е.
# сократится до одного элемента.
# А один элемент уж точно можно считать отсортированным относительно себя.
# Полпути сортировки можно считать пройденной.

# Дальше — интереснее.
# Нам нужно склеивать обратно расщепленные части массива,
# потому она и называется сортировкой слиянием.
# Итак, имеем два одиночных элемента — сравниваем их и возвращаем на предыдущий уровень рекурсии в нужном порядке.
# Когда имеем больше элементов в каждой из частей, подлежащих слиянию, нужно быть предельно аккуратным:
#         Сравниваем первые элементы.
#         В результирующий массив записываем наименьший.
#         Сравниваем первый элемент в нетронутом и второй элемент из другой части.
#         Сравниваем — склеиваем в результат.
#         И так продолжается, пока не будет достигнут конец одной из частей.
#         Последний штрих — в результирующий массив записать все элементы из еще пока непустой части.
#

array = [2, 3, 1, 4, 6, 5, 9, 8, 7]


# функция сортировки слиянием
def merge_sort(arr):
    if len(arr) < 2:  # если в массиве один элемент
        return arr[:]  # возвращаем массив
    else:  # иначе
        middle = len(arr) // 2  # находим примерную середину массива
        left = merge_sort(arr[:middle])  # задаем левую часть
        right = merge_sort(arr[middle:])  # задаем правую часть
        return merge(left, right)  # вызываем функцию слияния, передав правую и левую части


# функция слияния
def merge(left, right):
    result = []  # создаем пустой список для возврата результата
    i, j = 0, 0  # задаем элементы == 0
    # пока i меньше значения длины левой части и j меньше правой:
    while i < len(left) and j < len(right):
        # если i-тый элемент слева меньше j-того элемента справа
        if left[i] < right[j]:
            # добавляем i-тый элемент из левой части в результирующий список
            result.append(left[i])
            # и увеличиваем i на 1
            i += 1
        # иначе
        else:
            # записываем в результат j-тый элемент из правой части
            result.append(right[j])
            j += 1
    # после завершения первого цикла:
    # пока i меньше длины левой части:
    while i < len(left):
        # записываем элемент из левой части в результат
        result.append(left[i])
        # и переходим к следующему элементу
        i += 1
    # потом, делаем то же самое с правой частью
    while j < len(right):
        result.append(right[j])
        j += 1
    # в конце, возвращаем список
    return result


print(merge_sort(array))